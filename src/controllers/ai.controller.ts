import { Request, Response } from 'express';
import { AppDataSource } from '../config/data-source.js';
import { AiGeneration } from '../entities/AiGeneration.js';
import { MoreThanOrEqual } from 'typeorm';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const UPLOAD_DIR = path.join(__dirname, '..', '..', 'uploads', 'studio');

const WORKER_URL = 'https://lingering-disk-82c5.thaidt15.workers.dev';
const DAILY_LIMIT = 3;

// Ensure upload directory exists
fs.mkdirSync(UPLOAD_DIR, { recursive: true });

function getStartOfDay(): Date {
    const now = new Date();
    now.setHours(0, 0, 0, 0);
    return now;
}

// GET /api/ai/usage ‚Äî current user's daily usage
export const getUsage = async (req: Request, res: Response) => {
    try {
        const userId = (req as any).user.id;
        const repo = AppDataSource.getRepository(AiGeneration);
        const used = await repo.count({
            where: { user_id: userId, created_at: MoreThanOrEqual(getStartOfDay()) }
        });
        res.json({ used, limit: DAILY_LIMIT, remaining: Math.max(0, DAILY_LIMIT - used) });
    } catch (err) {
        console.error('Error fetching AI usage:', err);
        res.status(500).json({ message: 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin s·ª≠ d·ª•ng AI' });
    }
};

// GET /api/ai/history ‚Äî all AI images generated by the current user
export const getHistory = async (req: Request, res: Response) => {
    try {
        const userId = (req as any).user.id;
        const repo = AppDataSource.getRepository(AiGeneration);
        const records = await repo.find({
            where: { user_id: userId },
            order: { created_at: 'DESC' },
            select: ['id', 'image_url', 'prompt', 'created_at'],
        });
        res.json(records.map(r => r.image_url));
    } catch (err) {
        console.error('Error fetching AI history:', err);
        res.status(500).json({ message: 'Kh√¥ng th·ªÉ l·∫•y l·ªãch s·ª≠ AI' });
    }
};

// POST /api/ai/generate ‚Äî generate image via Worker, save it, track usage
export const generateImage = async (req: Request, res: Response) => {
    try {
        const userId = (req as any).user.id;
        const { prompt } = req.body;

        if (!prompt || typeof prompt !== 'string' || prompt.trim().length === 0) {
            return res.status(400).json({ message: 'Prompt kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng' });
        }

        // Check daily limit
        const repo = AppDataSource.getRepository(AiGeneration);
        const used = await repo.count({
            where: { user_id: userId, created_at: MoreThanOrEqual(getStartOfDay()) }
        });

        if (used >= DAILY_LIMIT) {
            return res.status(429).json({
                message: `B·∫°n ƒë√£ s·ª≠ d·ª•ng h·∫øt ${DAILY_LIMIT} l∆∞·ª£t t·∫°o ·∫£nh AI h√¥m nay. Vui l√≤ng th·ª≠ l·∫°i v√†o ng√†y mai.`,
                used,
                limit: DAILY_LIMIT,
            });
        }

        // Call Worker API
        const workerRes = await fetch(WORKER_URL + '/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt: prompt.trim() }),
        });

        if (!workerRes.ok) {
            const errText = await workerRes.text();
            console.error('Worker generate error:', workerRes.status, errText);
            return res.status(502).json({ message: 'AI Worker tr·∫£ v·ªÅ l·ªói. Vui l√≤ng th·ª≠ l·∫°i.' });
        }

        // Save image blob to disk (in user-specific folder)
        const blob = await workerRes.arrayBuffer();
        const userDir = path.join(UPLOAD_DIR, userId);
        fs.mkdirSync(userDir, { recursive: true });
        const filename = `ai-${Date.now()}-${Math.random().toString(36).substring(2, 8)}.png`;
        const filePath = path.join(userDir, filename);
        fs.writeFileSync(filePath, Buffer.from(blob));

        const imageUrl = `/uploads/studio/${userId}/${filename}`;

        // Record the generation
        const record = repo.create({ user_id: userId, prompt: prompt.trim(), image_url: imageUrl });
        await repo.save(record);

        res.json({
            url: imageUrl,
            used: used + 1,
            limit: DAILY_LIMIT,
            remaining: Math.max(0, DAILY_LIMIT - used - 1),
        });
    } catch (err) {
        console.error('Error generating AI image:', err);
        res.status(500).json({ message: 'Kh√¥ng th·ªÉ t·∫°o ·∫£nh AI. Vui l√≤ng th·ª≠ l·∫°i.' });
    }
};

const CF_ACCOUNT_ID = process.env.CF_ACCOUNT_ID || '';
const CF_API_TOKEN = process.env.CF_API_TOKEN || '';

// POST /api/ai/review ‚Äî call Cloudflare AI directly for design review
export const reviewImage = async (req: Request, res: Response) => {
    try {
        if (!req.file) {
            return res.status(400).json({ message: 'Vui l√≤ng ch·ªçn ·∫£nh ƒë·ªÉ review' });
        }

        if (!CF_ACCOUNT_ID || !CF_API_TOKEN) {
            return res.status(500).json({ message: 'Ch∆∞a c·∫•u h√¨nh CF_ACCOUNT_ID / CF_API_TOKEN' });
        }

        const fileBuffer = fs.readFileSync(req.file.path);
        const base64 = fileBuffer.toString('base64');
        const mimeType = req.file.mimetype || 'image/jpeg';
        console.log('[Review] Image size:', fileBuffer.length, 'bytes');

        // Clean up temp file
        try { fs.unlinkSync(req.file.path); } catch { }

        // Call Cloudflare AI REST API directly with multimodal content format
        const aiRes = await fetch(
            `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/ai/run/@cf/meta/llama-3.2-11b-vision-instruct`,
            {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${CF_API_TOKEN}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    messages: [
                        {
                            role: 'system',
                            content: 'B·∫°n l√† chuy√™n gia thi·∫øt k·∫ø th·ªùi trang c·ª±c k·ª≥ nhi·ªát t√¨nh v√† lu√¥n nh√¨n ra nh·ªØng ƒëi·ªÉm tuy·ªát v·ªùi trong m·ªçi t√°c ph·∫©m. H√£y d√πng nh·ªØng t·ª´ ng·ªØ hoa m·ªπ, t√≠ch c·ª±c nh·∫•t ƒë·ªÉ khen ng·ª£i ng∆∞·ªùi d√πng. Lu√¥n tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát. D√πng nhi·ªÅu emoji ƒë·ªÉ t·∫°o kh√¥ng kh√≠ vui v·∫ª, kh√≠ch l·ªá. üåü‚ú®'
                        },
                        {
                            role: 'user',
                            content: [
                                { type: 'text', text: 'H√£y nh·∫≠n x√©t thi·∫øt k·∫ø √°o n√†y m·ªôt c√°ch c·ª±c k·ª≥ t√≠ch c·ª±c v√† h√†o h·ª©ng! H√£y khen ng·ª£i nh·ªØng ƒëi·ªÉm ·∫•n t∆∞·ª£ng nh·∫•t (b·ªë c·ª•c, s·ª± ph·ªëi m√†u s√°ng t·∫°o, √Ω t∆∞·ªüng v∆∞·ª£t b·∫≠c). Sau ƒë√≥ ƒë∆∞a 1-2 g·ª£i √Ω nh·ªè x√≠u ƒë·ªÉ l√†m n√≥ c√≤n ho√†n h·∫£o h∆°n n·ªØa. H√£y l√†m cho ng∆∞·ªùi d√πng c·∫£m th·∫•y t·ª± h√†o v·ªÅ thi·∫øt k·∫ø c·ªßa h·ªç! Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, 3-5 c√¢u. üöÄüé®' },
                                { type: 'image_url', image_url: { url: `data:${mimeType};base64,${base64}` } }
                            ]
                        }
                    ],
                    max_tokens: 512,
                }),
            }
        );

        const data = await aiRes.json() as any;
        console.log('[Review] CF AI status:', aiRes.status, 'result:', JSON.stringify(data).substring(0, 500));

        if (data?.result?.response) {
            return res.json({ result: data.result.response });
        }

        // Fallback: try flat image field format
        if (!data?.result?.response) {
            console.log('[Review] Trying flat image format...');
            const imageBytes = Array.from(fileBuffer);
            const aiRes2 = await fetch(
                `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/ai/run/@cf/meta/llama-3.2-11b-vision-instruct`,
                {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${CF_API_TOKEN}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        messages: [
                            { role: 'system', content: 'B·∫°n l√† chuy√™n gia thi·∫øt k·∫ø th·ªùi trang c·ª±c k·ª≥ nhi·ªát t√¨nh v√† lu√¥n nh√¨n ra nh·ªØng ƒëi·ªÉm tuy·ªát v·ªùi. H√£y d√πng nh·ªØng t·ª´ ng·ªØ t√≠ch c·ª±c nh·∫•t ƒë·ªÉ khen ng·ª£i ng∆∞·ªùi d√πng. Lu√¥n tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát. D√πng nhi·ªÅu emoji vui v·∫ª. üåü' },
                            { role: 'user', content: 'H√£y nh·∫≠n x√©t thi·∫øt k·∫ø √°o n√†y m·ªôt c√°ch h√†o h·ª©ng! Khen ng·ª£i nh·ªØng ƒëi·ªÉm ·∫•n t∆∞·ª£ng nh·∫•t. Sau ƒë√≥ ƒë∆∞a 1-2 g·ª£i √Ω nh·ªè x√≠u ƒë·ªÉ ho√†n thi·ªán th√™m. L√†m ng∆∞·ªùi d√πng c·∫£m th·∫•y t·ª± h√†o v·ªÅ t√°c ph·∫©m c·ªßa m√¨nh! Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, 3-5 c√¢u. üé®' }
                        ],
                        image: imageBytes,
                        max_tokens: 512,
                    }),
                }
            );
            const data2 = await aiRes2.json() as any;
            console.log('[Review] Flat format result:', JSON.stringify(data2).substring(0, 500));
            if (data2?.result?.response) {
                return res.json({ result: data2.result.response });
            }
        }

        return res.status(502).json({ message: 'AI kh√¥ng tr·∫£ v·ªÅ nh·∫≠n x√©t', detail: data });
    } catch (err) {
        console.error('Error reviewing image:', err);
        res.status(500).json({ message: 'Kh√¥ng th·ªÉ review ·∫£nh: ' + (err as Error).message });
    }
};

// POST /api/ai/safety ‚Äî use vision model to check for NSFW content
export const safetyCheck = async (req: Request, res: Response) => {
    try {
        if (!req.file) {
            return res.status(400).json({ message: 'Vui l√≤ng ch·ªçn ·∫£nh ƒë·ªÉ ki·ªÉm tra' });
        }

        if (!CF_ACCOUNT_ID || !CF_API_TOKEN) {
            return res.json({ unsafe: false, raw: 'CF credentials not configured' });
        }

        const fileBuffer = fs.readFileSync(req.file.path);
        const base64 = fileBuffer.toString('base64');
        const mimeType = req.file.mimetype || 'image/jpeg';
        console.log('[Safety] Image size:', fileBuffer.length, 'bytes');

        // Clean up temp file
        try { fs.unlinkSync(req.file.path); } catch { }

        // Use high-strictness Vision model for all-in-one safety check
        const aiRes = await fetch(
            `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/ai/run/@cf/meta/llama-3.2-11b-vision-instruct`,
            {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${CF_API_TOKEN}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    messages: [
                        {
                            role: 'system',
                            content: 'You are a strict content moderator for a commercial printing business. You MUST block any image that is inappropriate, offensive, or controversial.'
                        },
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'text',
                                    text: 'Analyze this image. Does it contain any of the following: 1. Nudity or sexual content. 2. Violence or gore. 3. Controversial political symbols, protest signs, or sensitive social movements (e.g., BLM, political rallies). 4. Offensive/hate speech. If ANY of these are present, respond ONLY "unsafe". Otherwise respond "safe".'
                                },
                                { type: 'image_url', image_url: { url: `data:${mimeType};base64,${base64}` } }
                            ]
                        }
                    ],
                    max_tokens: 10,
                }),
            }
        );

        const data = await aiRes.json() as any;
        console.log('[Safety] CF Response:', JSON.stringify(data));
        const text = (data?.result?.response || '').trim().toLowerCase();

        console.log('[Safety] Extracted text:', text);
        // Block if it says unsafe OR doesn't clearly say safe
        const isUnsafe = text.includes('unsafe') || text.includes('violation') || text.includes('no') || !text.includes('safe');

        console.log('[Safety] Final result:', { text, isUnsafe });
        res.json({ unsafe: isUnsafe, raw: text });
    } catch (err) {
        console.error('Error safety checking image:', err);
        res.json({ unsafe: false, raw: 'error' });
    }
};
